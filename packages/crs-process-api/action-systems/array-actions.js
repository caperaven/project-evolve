class d{static async perform(a,r,s,e){await this[a.action](a,r,s,e)}static async add(a,r,s,e){const t=await crs.process.getValue(a.args.target,r,s,e),l=await crs.process.getValue(a.args.value,r,s,e);t!=null&&l!=null?t.push(l):console.error(`can't add to array - array is null:${t==null}, value is null:${l==null}`)}static async move(a,r,s,e){const t=await crs.process.getValue(a.args.action,r,s,e),l=await crs.process.getValue(a.args.source,r,s,e),c=await crs.process.getValue(a.args.source_item,r,s,e),i=l.indexOf(c),u=await crs.process.getValue(a.args.target||l,r,s,e),g=await crs.process.getValue(a.args.target_item,r,s,e);if(l.splice(i,1),t==="append")return u.push(c);if(t==="prepend")return u.unshift(c);if(t==="insert"){const n=await crs.process.getValue(a.args.index,r,s,e);return u.splice(n,0,c)}if(t==="move_up"){const n=i-1;return u.splice(n,0,c)}if(t==="move_down"){const n=i+1;return u.splice(n,0,c)}if(t==="before"){const n=u.indexOf(g);return u.splice(n,0,c)}if(t==="after"){const n=u.indexOf(g)+1;return u.splice(n,0,c)}}static async remove(a,r,s,e){const t=await crs.process.getValue(a.args.target,r,s,e),l=await crs.process.getValue(a.args.value,r,s,e),c=t?.indexOf(l);t!=null&&l!=null&&c!==-1?t.splice(c,1):console.error(`can't remove from array - array is null:${t==null}, value is null:${l==null}, value is not contained within target`)}static async transfer(a,r,s,e){const t=await crs.process.getValue(a.args.source,r,s,e),l=await crs.process.getValue(a.args.target,r,s,e),c=await crs.process.getValue(a.args.value,r,s,e);await this.add({args:{target:l,value:c}},r,s,e),await this.remove({args:{target:t,value:c}},r,s,e)}static async field_to_csv(a,r,s,e){const t=await crs.process.getValue(a.args.source,r,s,e);if(t==null)return console.error("fieldToCSV - target array does not exist");let l;const c=await crs.process.getValue(a.args.delimiter,r,s,e)||",";return a.args.field!=null?l=w(t,a.args.field,c):a.args.fields!=null&&(l=V(t,a.args.fields,c)),a.args.target!=null&&await crs.process.setValue(a.args.target,l,r,s,e),l}static async concat(a,r,s,e){let t=[];const l=await crs.process.getValue(a.args.sources,r,s,e);for(let c of l){let i=await crs.process.getValue(c,r,s,e);t=[...t,...i]}return a.args.target!=null&&await crs.process.setValue(a.args.target,t,r,s,e),t}static async change_values(a,r,s,e){const t=await crs.process.getValue(a.args.source,r,s,e),l=Object.keys(a.args.changes);let c={};for(let i of l)c[i]=await crs.process.getValue(a.args.changes[i],r,s,e);for(let i of t)for(let u of l)i[u]=c[u]}static async get_value(a,r,s,e){let l=(await crs.process.getValue(a.args.source,r,s,e))[a.args.index][a.args.field];return a.args.target!=null&&await crs.process.setValue(a.args.target,l,r,s,e),l}static async map_objects(a,r,s,e){const t=await crs.process.getValue(a.args.source,r,s,e)??[],l=a.args.fields??[];let c=[];for(const i of t){const u=await Promise.all(l.map(g=>crs.binding.utils.getValueOnPath(i,g)));c.push(...u)}return a.args.target!=null&&await crs.process.setValue(a.args.target,c,r,s,e),c}static async get_records(a,r,s,e){const t=[],l=await crs.process.getValue(a.args.source,r,s,e),c=await crs.process.getValue(a.args.page_number,r,s,e),i=await crs.process.getValue(a.args.page_size,r,s,e),u=await crs.process.getValue(a.args.fields,r,s,e);for(let g=c;g<c+i&&l[g]!=null;g++)if(u==null)t.push(l[g]);else{let n={};for(let f of u)n[f]=l[g][f];t.push(n)}return a.args.target!=null&&await crs.process.setValue(a.args.target,t,r,s,e),t}static async get_range(a,r,s,e){const t=await crs.process.getValue(a.args.source,r,s,e),l=await crs.process.getValue(a.args.field,r,s,e),c={min:Number.MAX_VALUE,max:Number.MIN_VALUE};for(let i of t){const u=i[l];u<c.min&&(c.min=u),u>c.max&&(c.max=u)}return a.args.target!=null&&await crs.process.setValue(a.args.target,c,r,s,e),c}static async calculate_paging(a,r,s,e){const t=await crs.process.getValue(a.args.source,r,s,e),l=await crs.process.getValue(a.args.page_size,r,s,e),c=Math.ceil(t.length/l);let i={row_count:t.length,page_count:c};return a.args.target!=null&&await crs.process.setValue(a.args.target,i,r,s,e),i}static async map_assign_data(a,r,s,e){const t=await crs.process.getValue(a.args.source,r,s,e),l=await crs.process.getValue(a.args.mappings,r,s,e),c=Object.keys(l),i=Object.keys(t[0]??{});for(const u of t)for(let g of c){let n=l[g];if(g=await crs.process.getValue(g,r,s,e),n=await crs.process.getValue(n,r,s,e),n==null){u[g]=null;continue}if(i.indexOf(n)==-1){u[g]=n;continue}u[g]=u[n]}return a.args.target!=null&&await crs.process.setValue(a.args.target,t,r,s,e),t}static async delete_properties(a,r,s,e){const t=await crs.process.getValue(a.args.source,r,s,e),l=await crs.process.getValue(a.args.properties,r,s,e);for(const c of t)for(const i of l)delete c[i]}}async function w(o,a,r){return o.map(e=>e[a]).join(r||",")}async function V(o,a,r){let s=[];for(let e of o){let t=[];for(let l of a)t.push(e[l]);s.push(t.join(r))}return s}crs.intent.array=d;export{d as ArrayActions};

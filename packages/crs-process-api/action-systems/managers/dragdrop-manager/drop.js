import{createPlaceholderElement as s}from"./placeholder.js";async function h(e,n,t){t.currentAction="drop";const a=Array.from(this.element.children),i=a.indexOf(n),o=await y.call(this,e,t);let l=a.indexOf(o?.target);l>i&&l--,l==-1&&(l=a.length-1),o==null||o.target.classList.contains("placeholder")?await r(e,n,t):(o.position=="append"&&await c.call(this,e,o.target,t,n),o.position=="before"&&await u.call(this,e,o.target,t,n)),p(e,n,t),o?.target!=null&&t.drop.callback!=null&&await t.drop.callback(i,l,e)}async function r(e,n,t){if(await f(e,n._bounds),e._dragElement!=null){const a=e._dragElement;delete e._dragElement,e=a}(t.drag.clone==="element"||t.drag.clone==="template")&&n.parentElement.replaceChild(e,n)}async function c(e,n,t,a){let i=a;(a.parentElement!==this.element||t.drop.action=="copy")&&(i=await s(a._bounds)),n.appendChild(i),i._bounds=i.getBoundingClientRect(),await r(e,i,t)}async function u(e,n,t,a){let i=a;(a.parentElement!==this.element||t.drop.action=="copy")&&(i=await s(a._bounds)),n.parentElement.insertBefore(i,n),i._bounds=i.getBoundingClientRect(),await r(e,i,t)}function f(e,n){return new Promise(t=>{const a=setTimeout(()=>{e.style.transition="translate 0.3s ease-out",e.style.translate=`${n.x}px ${n.y}px`}),i=setTimeout(()=>{clearTimeout(a),clearTimeout(i),e.remove(),t()},350)})}function p(e,n,t){delete e._bounds,e.style.width="",e.style.height="",e.style.rotate="",e.style.translate="",e.style.transition="",e.style.filter="",t.drag?.placeholderType=="opacity"&&t.drop?.action=="copy"&&(n.style.opacity=1),delete n._bounds}async function y(e,n){const t=this.composedPath[0];return t==null?null:t.classList.contains("placeholder")?{target:t,position:"before"}:d[typeof n.drop.allowDrop].call(this,n,t)}class d{static async string(n,t){return t.matches(n.drop.allowDrop)?{target:t,position:"append"}:t.parentElement?.matches(n.drop.allowDrop)?{target:t.parentElement,position:"append"}:null}static async function(n,t){return await n.drop.allowDrop(t,n)}}export{y as allowDrop,h as drop};

const d="_meta",m="meta_database",D=1;class p{#e;#t=null;#c=[];#s(e){if(e.length!==0)return this.#r(t=>{let r;for(const s of e)r=t.put(s,s.storeName);return r},"readwrite",d)}#n(e){return this.#r(t=>t.get(e),"readonly",d)}#o(e,t){return this.#r(r=>r.put(e,t),"readwrite",d)}#a(e,t=!0,r=!0){return this.#r(async s=>{for(const n of e){const a=s.get(n),c=await new Promise((i,o)=>{a.onsuccess=u=>{i(u.target.result)},a.onerror=u=>{o(u)}});t&&(c.count=0),r&&(c.timestamp=null),s.put(c,n)}},"readwrite",d)}connect(e,t,r,s){return new Promise((n,a)=>{this.#e=e;const c=[],i=self.indexedDB.open(this.#e,t);i.onerror=o=>{a(o.target.error)},i.onsuccess=async o=>{this.#t=o.target.result,await this.#s(c),g(e),n()},i.onupgradeneeded=o=>{const u=o.target.result;if(u.objectStoreNames.contains(d)===!1&&u.createObjectStore(d),r>0)for(let l=0;l<r;l++){const y=`table_${l<10?`0${l}`:l}`;u.createObjectStore(y).createIndex("idIndex","id",{unique:!0}),c.push({storeName:y,timestamp:null,count:0})}for(const l of s)u.objectStoreNames.contains(l)===!1&&(u.createObjectStore(l).createIndex("idIndex","id",{unique:!0}),c.push({storeName:l,timestamp:null,count:0}))}})}async disconnect(){this.#t&&(this.#t.close(),this.#t=null)}#r(e,t="readwrite",r){return new Promise(async(s,n)=>{const a=this.#t.transaction([r],t);a.onerror=o=>{n(o.target.error)};const c=a.objectStore(r),i=await e(c);i?(i.onsuccess=o=>(g(this.#e),s(o.target.result)),i.onerror=o=>n(o.target.error)):s()})}markNextTableAsUsed(){return new Promise((e,t)=>{const r=this.#t.transaction([d],"readwrite");r.onerror=a=>{t(a.target.error)};const s=r.objectStore(d),n=s.openCursor();n.onsuccess=async a=>{let c=a.target.result;do{const i=c.value,o=i.storeName;if(i.timestamp==null){const l=c.value;l.timestamp=new Date,s.put(l,o),e(o);break}}while(c.continue())},n.onerror=a=>{t(a.target.error)}})}getAvailableStore(){return new Promise(async(e,t)=>{const r=await this.markNextTableAsUsed().catch(s=>t(s));e(r)})}releaseStores(e){return new Promise(async(t,r)=>{Array.isArray(e)===!1&&(e=[e]),this.clear(e,!0,!0).then(()=>t()).catch(s=>r(s))})}set(e,t,r=!1){return new Promise(async(s,n)=>{e||=await this.getAvailableStore().catch(c=>n(c)),r==!0&&await this.clear([e],!0,!1).catch(c=>n(c));const a=await this.#n(e).catch(c=>n(c));await new Promise((c,i)=>{this.#r(async o=>{for(const u of t)await o.put(u,a.count),a.count+=1;c()},"readwrite",e).catch(o=>i(o))}),a.timestamp=new Date,await this.#o(a,e).catch(c=>n(c)),s(e)})}add(e,t,r){return this.#r(s=>{const n=r.count;return r.count+=1,s.add(t,n)},"readwrite",e)}addWithIndex(e,t,r){return this.#r(s=>s.add(t,r),"readwrite",e)}get(e,t){return this.#r(r=>r.get(t),"readonly",e)}update(e,t,r){return this.#r(s=>s.put(t,r),"readwrite",e)}deleteByIndex(e,t){return this.#r(r=>{Array.isArray(t)===!1&&(t=[t]);let s;for(const n of t)s=r.delete(n);return s},"readwrite",e)}deleteRange(e,t,r){return this.#r(s=>s.delete(IDBKeyRange.bound(t,r)),"readwrite",e)}async clear(e,t=!0,r=!0){await this.#a(e,t,r);const s=[];for(let n of e)s.push(this.#r(a=>a.clear(),"readwrite",n));return Promise.all(s)}getAll(e){return this.#r(t=>t.getAll(),"readonly",e)}getBatch(e,t,r){return new Promise((s,n)=>{const a=[],c=this.#t.transaction([e],"readonly");c.onerror=l=>{n(l.target.error)};const i=c.objectStore(e),o=IDBKeyRange.bound(t,r,!1,!1),u=i.openCursor(o);u.onsuccess=l=>{const h=l.target.result;h?(a.push(h.value),h.continue()):s(a)},u.onerror=l=>{n(l.target.error)}})}getRecordsByIndex(e,t){const r=t.map(s=>this.#r(n=>n.get(s),"readonly",e));return Promise.all(r)}getValues(e,t,r){return this.#r(s=>{const n=s.getAll(r);n.onsuccess=a=>a.target.result.map(o=>{const u={};for(const l of t)u[l]=o[l];return u})},"readonly",e)}hasKey(e,t){return this.#r(r=>r.getKey(t),"readonly",e)}getById(e,t){return new Promise(async(r,s)=>{const n=this.#t.transaction([e],"readonly");n.onerror=o=>{s(o.target.error)};const a=n.objectStore(e);Array.isArray(t)===!1&&(t=[t]);const c=a.index("idIndex"),i=[];for(const o of t)c.get(o).onsuccess=u=>{u.target.result!=null&&i.push(u.target.result)};n.oncomplete=()=>{r(i)}})}updateById(e,t){return new Promise(async(r,s)=>{Array.isArray(t)===!1&&(t=[t]);const n=this.#t.transaction([e],"readwrite");n.onerror=i=>{s(i.target.error)};const a=n.objectStore(e),c=a.index("idIndex");for(const i of t){const o=c.getKey(i.id);o.onsuccess=u=>{a.put(i,u.target.result)}}n.oncomplete=()=>{r()}})}deleteById(e,t){return new Promise(async(r,s)=>{const n=this.#t.transaction([e],"readwrite");n.onerror=i=>{s(i.target.error)};const a=n.objectStore(e),c=a.index("idIndex");Array.isArray(t)===!1&&(t=[t]);for(const i of t){const o=c.getKey(i);o.onsuccess=u=>{const l=u.target.result;a.delete(l)}}n.oncomplete=()=>{r()}})}delete_by_index(e,t){return new Promise(async(r,s)=>{const n=this.#t.transaction([e],"readwrite");n.onerror=c=>{s(c.target.error)};const a=n.objectStore(e);Array.isArray(t)===!1&&(t=[t]);for(const c of t)a.delete(c);n.oncomplete=()=>{r()}})}getOldDatbaseNames(){return new Promise((e,t)=>{const r=self.db.transaction([d],"readonly");r.onerror=i=>{console.error(i.target.error)};const n=r.objectStore(d).openCursor(),a=[],c=Date.now();n.onsuccess=i=>{const o=i.target.result;if(o)do{const u=o.value.timestamp;c-u>duration&&a.push(o.key)}while(o.continue());e()}})}changeByIndex(e,t,r){return new Promise(async(s,n)=>{const a=this.#t.transaction([e],"readwrite");a.onerror=o=>{n(o.target.error)};const c=a.objectStore(e);Array.isArray(t)===!1&&(t=[t]);const i=Object.keys(r);for(const o of t){const u=c.get(o);u.onsuccess=l=>{const h=l.target.result;for(const y in i)h[y]=r[y];c.put(h)}}a.oncomplete=()=>{s()}})}changeById(e,t,r){return new Promise(async(s,n)=>{const a=this.#t.transaction([e],"readwrite");a.onerror=o=>{n(o.target.error)};const c=a.objectStore(e),i=c.get(t);i.onsuccess=o=>{const u=o.target.result;for(const l in r)u[l]=r[l];c.put(u)},a.oncomplete=()=>{s()}})}}class b{#e={};#t(e,t,r){return new Promise(async(s,n)=>{this.#e[t]===void 0&&n({uuid:e,success:!1,error:new Error(`Database ${t} is not connected`)}),await r().then(a=>{s({uuid:e,success:!0,data:a})}).catch(a=>{n({uuid:e,success:!1,error:a})})})}connect(e,t,r,s,n){return new Promise(async(a,c)=>{this.#e[t]!==void 0&&a({uuid:e,result:!0});const i=new p;await i.connect(t,r,s,n).catch(o=>{c({uuid:e,result:!1,error:o})}),this.#e[t]=i,a({uuid:e,result:!0})})}disconnect(e,t){return this.#t(e,name,async()=>{Array.isArray(t)===!1&&(t=[t]);for(const r of t)delete this.#e[r]})}getAvailableStore(e,t){return this.#t(e,t,async()=>await this.#e[t].getAvailableStore())}releaseStores(e,t,r){return this.#t(e,t,async()=>await this.#e[t].releaseStores(r))}set(e,t,r,s,n){return this.#t(e,t,async()=>await this.#e[t].set(r,s,n))}add(e,t,r,s){return this.#t(e,t,async()=>await this.#e[t].add(r,s))}clear(e,t,r,s,n){return this.#t(e,t,async()=>await this.#e[t].clear(r,s,n))}get(e,t,r,s){return this.#t(e,t,async()=>Array.isArray(s)===!1?await this.#e[t].get(r,s):await this.#e[t].getRecordsByIndex(r,s))}getAll(e,t,r){return this.#t(e,t,async()=>await this.#e[t].getAll(r))}getBatch(e,t,r,s,n,a){return this.#t(e,t,async()=>(n||=s+a-1,await this.#e[t].getBatch(r,s,n)))}deleteByIndex(e,t,r,s){return this.#t(e,t,async()=>await this.#e[t].deleteByIndex(r,s))}deleteRange(e,t,r,s,n){return this.#t(e,t,async()=>await this.#e[t].deleteRange(r,s,n))}getById(e,t,r,s){return this.#t(e,t,async()=>await this.#e[t].getById(r,s))}updateById(e,t,r,s){return this.#t(e,t,async()=>await this.#e[t].updateById(r,s))}deleteOldDatabase(e,t){return new Promise(async(r,s)=>{let n=await S(t).catch(o=>s(o));n.length===0&&r({uuid:e,success:!0,data:null}),n=n.filter(o=>this.#e[o]==null);const a=[];for(const o of n)await new Promise(u=>{const l=indexedDB.deleteDatabase(o);l.onsuccess=()=>{a.push(o),u()},l.onerror=h=>{console.error(h.target.error)}});const c=self.metaDB.transaction([d],"readwrite"),i=c.objectStore(d);for(const o of a)i.delete(o);c.oncomplete=()=>{r({uuid:e,result:!0})}})}deleteDatabase(e,t){return new Promise((r,s)=>{this.#e[t]!=null&&(this.#e[t].disconnect(),delete this.#e[t]);const n=indexedDB.deleteDatabase(t);n.onerror=a=>{s({uuid:e,success:!1,error:a.target.error})},n.onsuccess=()=>{const i=self.metaDB.transaction([d],"readwrite").objectStore(d).delete(t);i.onsuccess=()=>{r({uuid:e,success:!0,data:null})},i.onerror=o=>{s({uuid:e,success:!1,error:o.target.error})}}})}deleteById(e,t,r,s){return this.#t(e,t,async()=>await this.#e[t].deleteById(r,s))}}function S(f){return new Promise(async(e,t)=>{const r=[],s=self.metaDB.transaction([d],"readonly"),n=s.objectStore(d),a=new Date,c=n.openCursor();c.onsuccess=async i=>{let o=i.target.result;for(;o;){const u=o.key,l=o.value.timestamp;a-l>f&&r.push(u),o=o.continue()}},s.oncomplete=()=>{e(r)}})}function A(){return new Promise((f,e)=>{const t=self.indexedDB.open(m,1);t.onerror=r=>{e(r.target.error)},t.onsuccess=async r=>{self.metaDB=r.target.result,f()},t.onupgradeneeded=r=>{r.target.result.createObjectStore(d)}})}function g(f){const e=self.metaDB.transaction([d],"readwrite");e.onerror=r=>{console.error(r.target.error)},e.objectStore(d).put({timestamp:new Date},f)}const w=[];A().then(()=>{self.manager=new b;for(const f of w)self.onmessage(f)}).catch(f=>console.error(f)),self.onmessage=async function(f){if(self.manager==null){w.push(f);return}const e=f.data.action,t=f.data.args,r=f.data.uuid;self.manager[e]&&await self.manager[e](r,...t).then(s=>self.postMessage(s)).catch(s=>self.postMessage(s))};

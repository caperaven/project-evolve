class p{static async perform(s,e,a,r){return await this[s.action](s,e,a,r)}static async assert_step(s,e,a,r){const t=await crs.process.getValue(s.args.source,e,a,r),c=await crs.process.getValue(s.args.process,e,a,r),i=await crs.process.getValue(s.args.step,e,a,r),l=await crs.process.getValue(s.args.required,e,a,r),n={passed:!0,process:c,step:i},o=t[c].steps[i];for(const u of l)await crs.call("object","assert",{source:o.args,properties:[u]})==!1&&(n.passed=!1,n.messages=n.messages||[],n.messages.push(`"${u}" must have a value`));return s.args.target!=null&&await crs.process.setValue(s.args.target,n,e,a,r),n}static async required(s,e,a,r,t){const c=await crs.call("object","assert",s.args,e,a,r);if(c&&s.pass_step!=null){const i=await crs.getNextStep(a,s.pass_step,t);await crs.process.runStep(i,e,a,r,t)}if(!c&&s.fail_step!=null){const i=await crs.getNextStep(a,s.fail_step,t);await crs.process.runStep(i,e,a,r,t)}return c}}crs.intent.validate=p;export{p as ValidateActions};
